#!/bin/bash
#
# Copyright (c) 2008, Dave Korn.
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     A copy of the GNU General Public License can be found at
#     http://www.gnu.org/
#
# Written by Dave Korn <dave.korn.cygwin@gmail.com>
#
#
# Converts a gpg dsa pub key file to a text s-expr for
# building into setup.exe's signature verification.
# Relies on having pgpdump installed.
#
# Usage:
#     gpg-key-to-s-expr.sh [-q|-e|-Q|-c|-C|-1] KEYFILE
#
#   -q means surround output in quotes to make it easier
# for use in a C #include fragment.  -e means escape the
# line ends.  -Q means both.  -c means output a C-style
# string for printing, -C makes the strine a one-liner and
# outputs a C header as well.  -1 means generate all the
# output on a single line.  Only one option should be
# specified or the behaviour is undefined.


# Usage: find_a_line DSACOEFFICIENT PGPDUMPFILE
# Returns the hex data for the named DSA coefficeint..
function find_a_line() {
  grep "DSA $1([0-9]* bits) -" < "$2" \
    | sed -e 's/^.*- //g' | tr -d ' '
}

# Usage: line_to_sexpr HEXDATA
# Convert hex data from find_a_line to s-expr format:
# prepends 00 to avoid signedness problems if high bit
# is set, and surrounds with hash marks.
function line_to_sexpr() {
  echo "#"`echo "$1" | sed -e's/^\([89A-Fa-f]\)/00\1/g'`"#"
}

quotes=
escapes=
starts=
mid=
header=
nl="\n"
ind="    "

if [ x$1 == x-q ] ;
then
  quotes='"'
  shift ;
fi
if [ x$1 == x-e ] ;
then
  escapes='\\'
  shift ;
fi
if [ x$1 == x-Q ] ;
then
  quotes='"'
  escapes='\\'
  shift ;
fi
if [ x$1 == x-c ] ;
then
  quotes='"'
  escapes="\\\\n$quotes"
  starts="$quotes"
  shift ;
fi
if [ x$1 == x-C ] ;
then
  quotes='"'
  escapes="$quotes"
  mid="$quotes"
  header="\\n/*  Autogenerated from: $2\\n *\\t\\t   by: $0\\n *\\t\\t   at: `date "+%c"`\\t\\t\\t*/\\n\\n"
  shift ;
fi
if [ x$1 == x-1 ] ;
then
  nl=
  ind=
  shift ;
fi

if [ $# -ne 1 ] ;
then
  echo "Missing KEYFILE arg"
  exit 1 ;
fi

TMPFILE=`mktemp -t "$(basename "$1").XXXXXXXXXX"` || exit 1

pgpdump -milpu "$1" >"$TMPFILE" || exit 1

# Yes, this could be done *far* more efficiently in any one of
# perl/awk/python/$YOURFAVOURITETOOL than by spawning a whole
# bunch of bashes, greps and seds.  No, I don't care.  Don't bug
# me about it until we have to run this script a million times a day!

dsa_p=`find_a_line p $TMPFILE`
dsa_q=`find_a_line q $TMPFILE`
dsa_g=`find_a_line g $TMPFILE`
dsa_y=`find_a_line y $TMPFILE`

dsa_p=`line_to_sexpr "$dsa_p"`
dsa_q=`line_to_sexpr "$dsa_q"`
dsa_g=`line_to_sexpr "$dsa_g"`
dsa_y=`line_to_sexpr "$dsa_y"`

echo -e $header$quotes"(public-key $escapes$nl\
$starts$ind$mid(dsa $escapes$nl\
$starts$ind$ind$mid(p $dsa_p) $escapes$nl\
$starts$ind$ind$mid(q $dsa_q) $escapes$nl\
$starts$ind$ind$mid(g $dsa_g) $escapes$nl\
$starts$ind$ind$mid(y $dsa_y)$escapes$nl\
$starts$ind$mid)$escapes$nl\
$starts$mid)$quotes$nl";

rm "$TMPFILE"
